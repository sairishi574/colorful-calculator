# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19yNuLYwB0mB4lYJL1EG3xySVSARhBo0Y
"""

# Install widgets support in Colab
!pip install ipywidgets --quiet


import ipywidgets as widgets
from IPython.display import display, clear_output
import math, operator, re

# Tokenizer
def tokenize(expr):
    tokens = re.findall(r'\d+\.?\d*|[+\-*/^()]|sqrt', expr)
    return tokens

# Define operators, their precedence, associativity, and corresponding functions
ops = {
    '+': 1, '-': 1,
    '*': 2, '/': 2,
    '^': 3
}

assoc = {
    '+': 'left', '-': 'left',
    '*': 'left', '/': 'left',
    '^': 'right'
}

op_funcs = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
    '^': operator.pow
}


# Shunting-yard to convert infix â†’ postfix (RPN)
def shunting_yard(tokens):
    output, stack = [], []
    for token in tokens:
        if re.fullmatch(r'\d+\.?\d*', token):
            output.append(token)
        elif token in ops:
            while stack and stack[-1] in ops:
                if (assoc[token] == 'left' and ops[token] <= ops[stack[-1]]) or \
                   (assoc[token] == 'right' and ops[token] < ops[stack[-1]]):
                    output.append(stack.pop())
                else:
                    break
            stack.append(token)
        elif token == '(':
            stack.append(token)
        elif token == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop() # Pop the '('
        elif token == 'sqrt':
            stack.append(token)
    while stack:
        output.append(stack.pop())
    return output


# Evaluate RPN
def eval_rpn(rpn):
    stack = []
    for token in rpn:
        if re.fullmatch(r'\d+\.?\d*', token):
            stack.append(float(token))
        elif token in op_funcs:
            b, a = stack.pop(), stack.pop()
            stack.append(op_funcs[token](a,b))
        elif token == 'sqrt':
            a = stack.pop()
            stack.append(math.sqrt(a))
    return stack[0]


def safe_eval(expr):
    return eval_rpn(shunting_yard(tokenize(expr)))

expr_display = widgets.Text(value="", placeholder="Enter expression...", layout=widgets.Layout(width="300px"))
result_display = widgets.Label(value="Result: ")


buttons = [
['7','8','9','/','sqrt'],
['4','5','6','*','^'],
['1','2','3','-','('],
['0','.','=','+',' ) '],
['C','DEL']
]


colors = {
'digits':'lightblue',
'ops':'orange',
'eq':'lightgreen',
'ctrl':'tomato',
'func':'violet'
}


current_expr = ""


out = widgets.Output()


def on_click(b):
    global current_expr
    if b.description == '=':
        try:
            result = safe_eval(current_expr)
            result_display.value = f"Result: {result}"
        except Exception as e:
            result_display.value = f"Error: {e}"
    elif b.description == 'C':
        current_expr = ""
        expr_display.value = ""
    elif b.description == 'DEL':
        current_expr = current_expr[:-1]
        expr_display.value = current_expr
    else:
        current_expr += b.description
        expr_display.value = current_expr


# Generate buttons
grid = []
for row in buttons:
    btns = []
    for char in row:
        style_color = colors['digits'] if char.isdigit() or char=='.' else \
                      colors['ops'] if char in ['+','-','*','/','^'] else \
                      colors['eq'] if char=='=' else \
                      colors['ctrl'] if char in ['C','DEL'] else colors['func']
        b = widgets.Button(description=char, layout=widgets.Layout(width='60px'))
        b.style.button_color = style_color
        b.on_click(on_click)
        btns.append(b)
    grid.append(widgets.HBox(btns))


ui = widgets.VBox([expr_display, result_display] + grid)
display(ui)